<!doctype html>
<html lang="en">
<head>
  <style type="text/css">

  </style>

</head> 

<body style="margin: 0;">


<!-- <div class="JSONinfo"> </div> -->

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/GeometryUtils.js"></script>
<script src="js/Stats.js"></script>

  <!-- load the font files -->

    <script src="fonts/gentilis_bold.typeface.js"></script>
    <script src="fonts/gentilis_regular.typeface.js"></script>

<script src="js/Detector.js"></script>

<script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
<!-- put script here to call to library -->

<script>

var scene, camera, renderer;

var group, textMesh1, textMesh2, textGeo, material;

// custom global variables
var targetList = [];
var objectList = [];
var projector, mouse = { x: 0, y: 0 };

var stats = new Stats();

var serverData = [];

var filterType = ["Undocumented","Alien","Illegal","Work"];
stats.setMode(0); // 0: fps, 1: ms

// align top-left
stats.domElement.style.position = 'absolute';
stats.domElement.style.left = '0px';
stats.domElement.style.top = '0px';

document.body.appendChild( stats.domElement );

init();
animate();


// nytimes articles
var articles = ["http://www.nytimes.com/2015/03/29/magazine/debunking-the-myth-of-the-job-stealing-immigrant.html", 
"http://www.nytimes.com/2015/04/27/opinion/parents-first-undocumented-second.html"];

// Debug stuffs
var isTrimmed = true;

var articleURL = articles[0];

// var xCoor; 
// var yCoor;
// var zCoor;

// var alienX; 
// var alienY;
// var alienZ;

var cameraPosition;


// var illegalX = 900; 
// var illegalY = 0;
// var illegalZ = 500;


// var workX = 1000; 
// var workY = 0;
// var workZ = -500;

// var undocumentedX = -900; 
// var undocumentedY = 0;
// var undocumentedZ = -500;



for (var i = 0; i < articles.length; i++){
  makeRequest(articles[i]);
}

function makeRequest(url)
{
  $.ajax({
    url: "http://127.0.0.1:1337/getData?url="+url,
    type: "GET",
    crossDomain: true,
      dataType: 'jsonp',///was suggested to save as text so it's not already parsed ------ doesn't work becuase jsonp allows for cross domain requests which I need when working with node.js
    success: function (response) {
      // The request succeeded
      //console.log(response);
      // console.log(response.results.comments);
      // console.log(response.results.comments.sentiment);
      //findAlien(response);
      //var test = handleJSON(response);

      serverData.push(response);
      // console.log(serverData);
      //handleJSON(response);
      //call a div here and save text to a div :    
      //$(".myDiv").append(JSON.stringify(response));
    },
    error: function (xhr, status) {
      // The request failed
        // console.log(status);
    }

  });
}


function handleJSON(filter) { 
          

  for (var i = 0; i < serverData.length; i++){
    // the json for an individual article
    var data = serverData[i];
    
    for (var j = 0; j < data.results.comments.length; j++) {
        var APItext = data.results.comments[j].commentBody;

      var sentimentValue = data.results.comments[j].sentiment.score;



      //var n = APItext.indexOf(filterType);
      // console.log(filter);

      // for (var i = 0; i < data.results.comments.length; i++) {
  //  var str = data.results.comments[i].commentBody;
  //  var n = str.indexOf("alien");
  //  console.log(n);

  //  if (n > -1 ) {
  //      $(".text").append("<p>" + str + "</p>");
  //  }

 var increase = -1000;

        if (filter == "alien" && APItext.includes('illegal')) {
          for (var i = 0; i < data.results.comments.length; i++) {
            increase += 100;
            createText(APItext, -800, increase, 500, sentimentValue/10);
        }
      }

        if (filter == "illegal" && APItext.includes('work')) {
          for (var i = 0; i < data.results.comments.length; i++) {
            increase += 100;
            createText(APItext, -2000, increase, 500, sentimentValue/10);
        }
      }

        if (filter == "undocumented" && APItext.includes('undocumented')) {
          for (var i = 0; i < data.results.comments.length; i++) {
            increase += 100;
            createText(APItext, 550, increase, 500, sentimentValue/10);
        }
      }

        if (filter == "work" && APItext.includes('alien')) {
         for (var i = 0; i < data.results.comments.length; i++) {
            increase += 100;
            createText(APItext, 2000, increase, 500, sentimentValue/10);
        }
     } 
      


      //var increase = -500;

        //console.log(APItext);

     //for (var k = 0; k < 50; k++) {

     //  var n = APItext.indexOf("Alien");

        // if (n > -1 ) {
     //      createText(APItext, 0, 0, 500 );
     //   }
     //  }

          // if (filter == "alien") {
          //   for (var i = 0; i < 50; i++) {
          //      increase += 1000;
          //      createText(APItext, -650, increase, -500 ); /// put parameter in create text 
          //   }
          // }

          //  if (filter == "illegal") {
          //    for (var i = 0; i < 50; i++) {
          //      increase += 1000;
          //     // objectList.push(APItext);
          //      createText(APItext, -1300, increase, -500 ); /// put parameter in create text 
          //   }
          // }

          //  if (filter == "undocumented") {
          //     for (var i = 0; i < 50; i++) {
          //      increase += 3000;
          //      //objectList.push(APItext);
          //      createText(APItext, 250, increase, -500 ); /// put parameter in create text 
          //   }
          // }

          //  if (filter == "work") {
          //     for (var i = 0; i < 50; i++) {
          //      increase += 1000;
          //      //objectList.push(APItext);
          //      createText(APItext, 1400, increase, -500 ); /// put parameter in create text 
          //   }
          // }
        
          //createText(APItext, ); /// put parameter in create text 
        
      }

    }
  }
//}

 // Sets up the scene.
  function init() {
container = document.createElement( 'div' );
  document.body.appendChild( container );
 
    // Create the scene and set the scene size.
    scene = new THREE.Scene();
    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight;

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2( 0xcccccc, 0.000001 );

// LIGHTS

        hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 1 );
        hemiLight.color.setHSL( 0.6, 1, 0.6 );
        hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
        hemiLight.position.set( 0, 500, 0 );
        scene.add( hemiLight );

        //

        dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
        dirLight.color.setHSL( 0.1, 1, 0.95 );
        dirLight.position.set( -1, 1.75, 1 );
        dirLight.position.multiplyScalar( 50 );
        scene.add( dirLight );

        dirLight.castShadow = true;

        dirLight.shadowMapWidth = 2048;
        dirLight.shadowMapHeight = 2048;

        var d = 50;

        dirLight.shadowCameraLeft = -d;
        dirLight.shadowCameraRight = d;
        dirLight.shadowCameraTop = d;
        dirLight.shadowCameraBottom = -d;

        dirLight.shadowCameraFar = 3500;
        dirLight.shadowBias = -0.0001;
        dirLight.shadowDarkness = 0.35;
        //dirLight.shadowCameraVisible = true;  

  

 // Create a renderer and add it to the DOM.
     renderer = new THREE.WebGLRenderer({antialias:true});
    //var renderer = new THREE.WebGLRenderer( { alpha: true } );
    renderer.setSize(WIDTH, HEIGHT);
    document.body.appendChild(renderer.domElement);
    renderer.setClearColor( scene.fog.color );


    // camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 30000 );
    //     camera.position.x = 0;
    //     camera.position.y = 0;
    //     camera.position.z = 500;

    camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 30000 );

      camera.position.x = 0; 
      camera.position.y = 0; 
      camera.position.z = 500; 

    scene.add(camera);
    // Create an event listener that resizes the renderer with the browser window.
    window.addEventListener('resize', function() {
      var WIDTH = window.innerWidth,
          HEIGHT = window.innerHeight;
      renderer.setSize(WIDTH, HEIGHT);
      camera.aspect = WIDTH / HEIGHT;
      camera.updateProjectionMatrix();
    });

     // Set the background color of the scene.
    renderer.setClearColorHex(0x333F47, 1);
 
 // Add OrbitControls so that we can pan around with the mouse.
    controls = new THREE.OrbitControls(camera, renderer.domElement);

    //////////////////////////////////////////////////////////////////////

  // this material causes a mesh to use colors assigned to faces
 var material = new THREE.MeshPhongMaterial({
        color: 0xdddddd
    });

    var textGeom = new THREE.TextGeometry( filterType[0], {
        font: 'gentilis' // Must be lowercase!
    });

    var textGeom1 = new THREE.TextGeometry( filterType[1], {
        font: 'gentilis' // Must be lowercase!
    });
 
  var textGeom2 = new THREE.TextGeometry( filterType[2], {
        font: 'gentilis' // Must be lowercase!
    });

    var textGeom3 = new THREE.TextGeometry( filterType[3], {
        font: 'gentilis' // Must be lowercase!
    });

  var Undocumented = new THREE.Mesh( textGeom, material );

 Undocumented.position.x = 250;
 Undocumented.position.y = -2500;
 Undocumented.position.z = -500;
 Undocumented.name = "Undocumented";
 Undocumented.updateMatrix();
 Undocumented.matrixAutoUpdate = false;

    scene.add(Undocumented );
  
  targetList.push(Undocumented);


  var Work = new THREE.Mesh( textGeom1, material );

 Work.position.x = 1900;
 Work.position.y = -2500;
 Work.position.z = -500;
 Work.name = "Work";
 Work.updateMatrix();
 Work.matrixAutoUpdate = false;

    scene.add(Work);
  
  targetList.push(Work);


 var Alien = new THREE.Mesh( textGeom2, material );

 Alien.position.x = -1000;
 Alien.position.y = -2500;
 Alien.position.z = -500;
 Alien.name = "Alien";
 Alien.updateMatrix();
 Alien.matrixAutoUpdate = false;

    scene.add(Alien);
  
  targetList.push(Alien);


 var Illegals = new THREE.Mesh( textGeom3, material );

 Illegals.position.x = -2000;
 Illegals.position.y = -2500;
 Illegals.position.z = -500;
 Illegals.name = "Illegal";
 Illegals.updateMatrix();
 Illegals.matrixAutoUpdate = false;

    scene.add(Illegals);
  
  targetList.push(Illegals);
  //////////////////////////////////////////////////////////////////////
  
  // initialize object to perform world/screen calculations
  projector = new THREE.Projector();
  
  // when the mouse moves, call the given function
  document.addEventListener( 'mousedown', onDocumentMouseDown, false );

 }

 function posCamera(camX, camY, camZ)
 {
      camera.position.x = camX; 
      camera.position.y = camY; 
      camera.position.z = camZ; 
  }

  function lookAtCamera(x, y, z) {

    console.log(camera);
    var pos = new THREE.Vector3(x, y, z);
    // camera.up = new THREE.Vector3(0,0,1);
    camera.lookAt(pos);
  }


  function onDocumentMouseDown( event ) 
{
  
  console.log("Click.");
  
  // update the mouse variable
  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  
  // find intersections

  // create a Ray with origin at the mouse position
  //   and direction into the scene (camera direction)
  var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
  projector.unprojectVector( vector, camera );
  var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

  // create an array containing all objects in the scene with which the ray intersects
  var intersects = ray.intersectObjects( targetList );
  
  // if there is one (or more) intersections
  if ( intersects.length > 0 )
  {
    console.log(intersects);
    console.log("Hit @ " + toString( intersects[0].point ) );
    // may throw error if undefined
    var filterText = intersects[0].object.name.toLowerCase();
    // console.log(filterText);
    // change the color of the closest face.

    handleJSON(filterText); 

  }

  var intersects1 = ray.intersectObjects(objectList);
  // console.log(objectList);

 if ( intersects1.length > 0 ) {
 console.log("IT WORKED");
 var objectPos = intersects1[0].object.position;
   console.log(intersects1);
 posCamera (objectPos.x, objectPos.y, objectPos.z - 100);
 lookAtCamera(objectPos.x, objectPos.y, objectPos.z);

  // } else {
  //  //camera (camXa, camYa, camZa);
  // camera (500, 0, 0);

   }
}


function toString(v) { return "[ " + v.x + ", " + v.y + ", " + v.z + " ]"; }


function animate() 
{
  requestAnimationFrame( animate );
  render();   
  update();
}

function update()
{
  
  controls.update();
}

function render() 
{
  renderer.render( scene, camera );
}



 function createText(v, POSX, POSY, POSZ, sentimentPos) {

   var v;

    // create a canvas element
    var canvas1 = document.createElement('canvas');
    canvas1.width = 500;
    canvas1.height = 2000;
    var context1 = canvas1.getContext('2d');
    context1.font = 'Bold 24px Arial';
    //context1.fillStyle = 'rgba(200, 200, 200,1.0)';
    context1.fillStyle = 'rgba(255, 200 , 255, 1.0)';
    wrapText(context1, v, 0, 70, 500, 50);


    context1.fillText(v, 0, 70);
    // canvas contents will be used for a texture
    var texture1 = new THREE.Texture(canvas1);
    texture1.needsUpdate = true;

    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side: THREE.DoubleSide } );
    material1.transparent = true;

    var mesh1 = new THREE.Mesh(
        new THREE.PlaneGeometry(canvas1.width, canvas1.height),
        material1
      );

    mesh1.position.x = POSX; //xCoor
    mesh1.position.y = POSY; //yCoor
    mesh1.position.z = POSZ * (sentimentPos); //zCoor

scene.add(mesh1);

    objectList.push(mesh1);

    }




function wrapText(context, text, x, y, maxWidth, lineHeight) {
  var words = text.split(' ');
  var line = '';
  for(var n = 0; n < words.length; n++) {
  var testLine = line + words[n] + ' ';
  var metrics = context.measureText(testLine);
  var testWidth = metrics.width;
  if (testWidth > maxWidth && n > 0) {
  context.fillText(line, x, y);
  line = words[n] + ' ';
  y += lineHeight;
  }
  else {
  line = testLine;
  }
  }
  context.fillText(line, x, y);
}


</script>

</body>
</html>