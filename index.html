<html>
<head>

	<style type="text/css">

	.myDiv {
		position: absolute;
    	left: 0px;
    	top: 0px;
    	width: 100px;
    	height: 100px;
    	background: white;
    	color: black;
	}
	</style>

</head> 

<body>

<div class="myDiv"> </div>

<!-- <div class="JSONinfo"> </div> -->

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/GeometryUtils.js"></script>

	<!-- load the font files -->

		<script src="fonts/gentilis_bold.typeface.js"></script>
		<script src="fonts/gentilis_regular.typeface.js"></script>

<script src="//code.jquery.com/jquery-1.11.2.min.js"></script>
<!-- put script here to call to library -->

<script>

var scene, camera, renderer;

var group, textMesh1, textMesh2, textGeo, material;



// nytimes articles
var articles = ["http://www.nytimes.com/2015/03/29/magazine/debunking-the-myth-of-the-job-stealing-immigrant.html", 
"http://www.nytimes.com/2015/04/27/opinion/parents-first-undocumented-second.html"];

var articleURL = articles[0];
for (var i = 0; i < articles.length; i++){
	makeRequest(articles[0]);
}

function makeRequest(url)
{
	$.ajax({
		url: "http://127.0.0.1:1337/getData?url="+url,
		type: "GET",
		crossDomain: true,
	    dataType: 'jsonp',///was suggested to save as text so it's not already parsed ------ doesn't work becuase jsonp allows for cross domain requests which I need when working with node.js
		success: function (response) {
			// The request succeeded
			//console.log(response);
			console.log(response.results.comments);
			console.log(response.results.comments.sentiment);
			//findAlien(response);
			//var test = handleJSON(response);

			//call a div here and save text to a div : 		
			$(".myDiv").append(JSON.stringify(response));

		},
		error: function (xhr, status) {
			// The request failed
	    	console.log(status);
		}

	});
}


		
// // handle JSON data from node backend
// function handleJSON(data) {	
// 	for (var i = 0; i < data.results.comments.length; i++) {
// 	$(".myDiv").append("data.results.comments[i]");
// 	}
// }

//{
// 	$.ajax({
// 		async: false;
// 		url: "http://127.0.0.1:1337/getData?url="+url,
// 		type: "GET",
// 		crossDomain: true,
// 	    dataType: 'jsonp', ///look up options for text and save as text so it's not already parsed 
// 		success: function (response) {
// 			// The request succeeded
// 			//console.log(response);
// 			console.log(response.results.comments);
// 			console.log(response.results.comments.sentiment);
// 			//findAlien(response);
// 			handleJSON(response);
// //call a div here and save text to a div 		
//     console.log("The file was saved!");
// });
// 			//drawText(response.results.comments); 
// 			//put data in div 
// 		},
// 		error: function (xhr, status) {
// 			// The request failed
// 	    	console.log(status);
// 		}

// 	});
// }

///find out text from div into parse JSON into handle JSON and then through draw text draws 

var myText = document.querySelector(".myDiv");

init();
animate();
//handleJSON($.parseJSON(myText)); ///figure out synatx
//handleJSON(JSON.parse(".myDiv")); --- additional research told me I'm getting an error here becuase the JSON is being parsed twiced 
handleJSON("myText");
//drawText(); 


function handleJSON(data) {	
	
	for (var i = 0; i < data.results.comments.length; i++) {
  		APItext = data.results.comments[i].commentBody;
  		drawText(APItext);
	}

}


function drawText(inText){ 

	var textGeom = new THREE.TextGeometry(inText, {
        font: 'gentilis' 
    });

    var textMesh = new THREE.Mesh( textGeom, material );

    textMesh.position.x = ( Math.random() - 0.5 ) * 5000;
	textMesh.position.y = ( Math.random() - 0.5 ) * 5000;
	textMesh.position.z = ( Math.random() - 0.5 ) * 5000;
	textMesh.updateMatrix();
	textMesh.matrixAutoUpdate = false;

    scene.add( textMesh );

}


// Sets up the scene.
function init() {

  	container = document.createElement( 'div' );
	document.body.appendChild( container );
 
    // Create the scene and set the scene size.
    scene = new THREE.Scene();
    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight;

 // Create a renderer and add it to the DOM.
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(WIDTH, HEIGHT);
    document.body.appendChild(renderer.domElement);

    // Create a camera, zoom it out from the model a bit, and add it to the scene.
    camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 20000);
    camera.position.set(0,6,0);
    scene.add(camera);


    var material = new THREE.MeshPhongMaterial({
        color: 0xdddddd
    });

    // Create an event listener that resizes the renderer with the browser window.
    window.addEventListener('resize', function() {
      var WIDTH = window.innerWidth,
          HEIGHT = window.innerHeight;
      renderer.setSize(WIDTH, HEIGHT);
      camera.aspect = WIDTH / HEIGHT;
      camera.updateProjectionMatrix();
    });

     // Set the background color of the scene.
    renderer.setClearColorHex(0x333F47, 1);
 
    // Create a light, set its position, and add it to the scene.
    var light = new THREE.PointLight(0xffffff);
    light.position.set(-100,200,100);
    scene.add(light);

 // Add OrbitControls so that we can pan around with the mouse.
    controls = new THREE.OrbitControls(camera, renderer.domElement);
 
 }




  // Renders the scene and updates the render as needed.
  function animate() {

    requestAnimationFrame(animate);
 
    // Render the scene.
    renderer.render(scene, camera);
    controls.update();
  }


//finding word alien 
// function findAlien(data) {

	// for (var i = 0; i < data.results.comments.length; i++) {
	// 	var str = data.results.comments[i].commentBody;
	// 	var n = str.indexOf("alien");
	// 	console.log(n);

	// 	if (n > -1 ) {
	//  		$(".text").append("<p>" + str + "</p>");
	// 	}
	// }
// }


/*
$.getJSON('timesOut1.json', function(data) {
    // loop through each comment
 

			for (var i = 0; i < data.results.comments.length; i++) {
				// get the comment body
				var comment = data.results.comments[i].commentBody;
				console.log(comment);	

			}

						var container = document.querySelector('text');

			var paragraph = document.createElement('p');
			paragraph.setAttribute("class", "text");
			paragraph.innerHTML = "these are comments" + comment;

			paragraph.appendChild(container);
				
				// do sentiment analysis
});
*/

</script>

</body>
</html>