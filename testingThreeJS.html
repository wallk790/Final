<!doctype html>
<html lang="en">
<head>
  <title>Figuring out text</title>
  <meta charset="utf-8">

<style>

</style>

</head>
<body style="margin: 0;">
 
  <script src="js/three.min.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/GeometryUtils.js"></script>

  <!-- load the font files -->

    <script src="fonts/gentilis_bold.typeface.js"></script>
    <script src="fonts/gentilis_regular.typeface.js"></script>

    <script src="js/Detector.js"></script>
  
<script src="//code.jquery.com/jquery-1.11.2.min.js"></script>

  <script>
 
  // Set up the scene, camera, and renderer as global variables.
  var scene, camera, renderer;

  var group, textMesh1, textMesh2, textGeo, material;


// custom global variables
var targetList = [];
var projector, mouse = { x: 0, y: 0 };

  init();
  animate();
  //createText();



  // Sets up the scene.
  function init() {

    container = document.createElement( 'div' );
  document.body.appendChild( container );
 
    // Create the scene and set the scene size.
    scene = new THREE.Scene();
    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight;

 // Create a renderer and add it to the DOM.
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(WIDTH, HEIGHT);
    document.body.appendChild(renderer.domElement);

    // Create a camera, zoom it out from the model a bit, and add it to the scene.
    camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 20000);
    camera.position.set(0,1,0);
    scene.add(camera);


    // Create an event listener that resizes the renderer with the browser window.
    window.addEventListener('resize', function() {
      var WIDTH = window.innerWidth,
          HEIGHT = window.innerHeight;
      renderer.setSize(WIDTH, HEIGHT);
      camera.aspect = WIDTH / HEIGHT;
      camera.updateProjectionMatrix();
    });

     // Set the background color of the scene.
    renderer.setClearColorHex(0x333F47, 1);
 
    // Create a light, set its position, and add it to the scene.
    var light = new THREE.PointLight(0xffffff);
    light.position.set(-100,200,100);
    scene.add(light);

 // Add OrbitControls so that we can pan around with the mouse.
    controls = new THREE.OrbitControls(camera, renderer.domElement);

    //////////////////////////////////////////////////////////////////////

  // this material causes a mesh to use colors assigned to faces
 var material = new THREE.MeshPhongMaterial({
        color: 0xdddddd
    });

    var textGeom = new THREE.TextGeometry( 'Click', {
        font: 'gentilis' // Must be lowercase!
    });


  var Click = new THREE.Mesh( textGeom, material );

 Click.position.x = 0;
 Click.position.y = 0;
 Click.position.z = 0;
 Click.updateMatrix();
 Click.matrixAutoUpdate = false;

    scene.add( Click );
  
  targetList.push(Click);

  //////////////////////////////////////////////////////////////////////
  
  // initialize object to perform world/screen calculations
  projector = new THREE.Projector();
  
  // when the mouse moves, call the given function
  document.addEventListener( 'mousedown', onDocumentMouseDown, false );
  
 
  }

  function onDocumentMouseDown( event ) 
{
  // the following line would stop any other event handler from firing
  // (such as the mouse's TrackballControls)
  // event.preventDefault();
  
  console.log("Click.");
  
  // update the mouse variable
  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  
  // find intersections

  // create a Ray with origin at the mouse position
  //   and direction into the scene (camera direction)
  var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
  projector.unprojectVector( vector, camera );
  var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

  // create an array containing all objects in the scene with which the ray intersects
  var intersects = ray.intersectObjects( targetList );
  
  // if there is one (or more) intersections
  if ( intersects.length > 0 )
  {
    console.log("Hit @ " + toString( intersects[0].point ) );
    // change the color of the closest face.
    createText(); 
  }

}


function toString(v) { return "[ " + v.x + ", " + v.y + ", " + v.z + " ]"; }

function animate() 
{
  requestAnimationFrame( animate );
  render();   
  update();
}

function update()
{
  
  controls.update();
}

function render() 
{
  renderer.render( scene, camera );
}


  // // Renders the scene and updates the render as needed.
  // function animate() {

  //   requestAnimationFrame(animate);
 
  //   // Render the scene.
  //   renderer.render(scene, camera);
  //   controls.update();
  // }

 function createText(v) {

var text = "Hello World! Hello World! alien! \ Hello World! Hello World!";
  for ( var i = 0; i < 150; i ++ ) {
    // create a canvas element
    var canvas1 = document.createElement('canvas');
    canvas1.width = 500;
    canvas1.height = 500;
    var context1 = canvas1.getContext('2d');
    context1.font = 'Bold 50px Arial';
    context1.fillStyle = 'rgba(255,255,255,1.0)';
    wrapText(context1, text, 0, 70, 500, 100);


    context1.fillText("Hello World! Hello World! alien! \ Hello World! Hello World!", 0, 70);
    // canvas contents will be used for a texture
    var texture1 = new THREE.Texture(canvas1);
    texture1.needsUpdate = true;

    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side: THREE.DoubleSide } );
    material1.transparent = true;

    var mesh1 = new THREE.Mesh(
        new THREE.PlaneGeometry(canvas1.width, canvas1.height),
        material1
      );

    mesh1.position.x = ( Math.random() - 0.5 ) * 2000;
    mesh1.position.y = ( Math.random() - 0.5 ) * 2000;
    mesh1.position.z = ( Math.random() - 0.5 ) * 2000;

    scene.add(mesh1);
  }
 
}


 </script>
 
</body>
</html>